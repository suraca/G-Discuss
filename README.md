
# G-Discuss Documentation


---
## The basics, structure, and use case

G-Discuss is a function-based language, where every function is the branch of a dialogue tree.
It is structured intuitively to lend itself to this single use-case, and nothing else, and should be treated as a tool for writing and displaying dialogue trees.

It will always run the first function in the script first.

Here is how a function is structured:

It starts with the function's name, and an open bracket. The function's end will be indicated via a closed bracket. Following that, there are multiple things you can do before displaying the players choices. Each keyword is optional, although you will usually use at least one. After these, you can display play options or actions. (Tying these to existing scripts and gameplay is very easy!)
Here is a *very* simple function, so that you can see how this structure will look in practice:

```
# (This is not functional code, it is just the structure)
path path_name_1 "/root"
path path_name_2 "/Node3D"

def FunctionOne(
STATE Johnathan 0
TEXT "The text spoken here"
STOP "Pauses_Until_Input"
TEXT "The text spoken here too"
options
	"Reply One" : [Requirement for option]
		[Things to do when option selected]
		
	"Reply Two" : [Requirement for option]
		[Things to do when option selected]

)
```

Here is the example that uses valid syntax. It demonstrated a lot of the important functionality of this tool.
```
path main_path "../root/Global"
standin name main_path currentName

def FuntionOne(
TEXT "Hello {name}"
STOP
TEXT "I know who you are"
options
	"How could you know?!" : UNC
		GOTO FunctionTwo()
		
	"Second dialogue option" : FLAG main_path "ExampleFlagOne"
		ADDFLAG main_path "ExampleFlagOne" GOTO FunctionThree()
)
```


---
## Creating and loading scripts

A GDiscuss script is a custom Resource called "DialogueFile".
As of 1.0, it has one property, called "code". This is where your dialogue script should go.
The plugin comes with an editor scene, which is a very basic code editor with syntax highlighting and a save and load feature. It also enables you to test scripts quickly.

Whenever you want to load a DialogueFile, you will need to send it through a "GDiscussInterpreter". You can create a new one by calling `GDiscussInterpreter.new()`, and you can then call the start function, with your dialogue file as the first parameter, and a container node as your second parameter. If no container is specified, then the dialogue's display box (DialogueDisplay.tscn) will be in it's default position, otherwise it will conform to the given container. When the dialogue is finished, it will emit the signal "done". It's start function will return whether or not the dialogue has started.

Here is an example function that you might write to start a dialogue tree.
```
func dialogue(file:DialogueFile):
	var i = GDiscussInterpreter.new()
	add_child(i)
	if i.start(DialogueFile,$AnyContainer):
		await i.done
	i.queue_free()
```



---
## The start of a function

What is the start of the function used for?
- Setting the speakers name, portrait, and portrait position
- Setting the theme of the dialogue box (Using Godot's built in theme system)
- Setting the text that is being spoken to the player


- STATE \[speaker_name] \[speaker_portrait_index] \[speaker_portrait_position] \[shader] \[file_type]
	- speaker_name is what will be displayed above the text, denoting who is speaking
	- speaker_portrait_index is which portrait will be used. It will look for a file called "\[speaker_name]\_\[speaker_portrait_index].\[file_type]"
	- This might look like `John_2.png` or `Emily_7.jpeg`
	- speaker_portrait_position is what side of the text box the portrait will be positioned. it is on the right side by default, and this parameter is optional.
	- \[shader] denotes what shader to apply to the portrait. This is an optional parameter, and can be skipped if you set this to "null". (You can set where files are stored in the Dialogue Display script ("DialogueDisplay.gd"))
	- file_type denotes what the filetype of the portrait is. It is .png by default, and this is an optional parameter. (You can set where files are stored in the interpreter script ("Interpreter.gd"))
	- A full STATE might like like this `STATE John 2 Right null png` or `STATE Zac 0 L shiny png` (This will load from the shader location set in the "DialogueDisplay" script) or even `STATE Penny 1 left null tres`. (The last one is if you want to use an image Resource generated by Godot, such as a noise texture, hence the "tres" file format)
- THEME \[theme_name]
	- This will set the Control node's theme (and by extent, all text box's element's theme) to be a theme with the name \[theme_name] at the given theme location. (You can set the theme location in the interpreter script ("Interpreter.gd"), under the variable "themeLocation")
- TEXT \[spoken_text]
	- This keyword just denotes what is being said at the start of this dialogue branch.
- STOP \[button_text]
	- This will pause after the dialouge is spoken, giving one option button displaying \[button_text], which is an optional parameter, and will be "Next" by default. This allows for multiple TEXT keywords separated by STOP, as to avoid having multiple functions with one option to just continue text. This allows it to all be in one function, reflecting that it is a linear dialogue branch.

The start of a function will look something like this. Note, after the start of a function, the keyword options is used to set the start of the player's options

```
def FunctionOne(
STATE Johnathan 1 Right null jpeg
TEXT "Hello!"
STOP "Next"
TEXT "How have you been"
options
```

After this, we reach the options stage

---
## Player options 

The start of player options is indicated by the "options", usually right after a "TEXT" line (although not necessarily).

After the "options" keyword, an indent is used to make the structure more clear to the reader.
An option is in three parts, that I will be referring to as: 
- Text
	- The option's text (Often representing a reply, or action), separated from the Requirements via a colon
- Requirements
	- The requirements for an option to appear (Use UNC for it to appear unconditionally)
- Actions
	- The resulting actions from picking the option, such as going to a dialogue branch.

```
options
	"Option's text" : UNC
		GOTO FunctionTwo()
	"Option's text 2" : UNC
		GOTO FunctionThree()
```

As many of these options can be added as needed.

### The Requirements
- UNC - This means it will show unconditionally
- FLAG \[node_path] \[flag]
	- This will check the "Flags" variable (assumed to be an Array of Strings) at the given path, \[node_path]. Returns true if it exists, otherwise, false.
- VALUE \[node_path] \[variable_name] \[operator] \[value]
	- This will compare \[value] of the variable \[variable_name] at the given path, \[node_path] using \[operator]. \[value]'s type will be a float if it is a valid float, or a boolean if it is a valid boolean.
	- Operators that are allowed are the supported set of operators, defined later in this section
	- This might look like: `"Text" : VALUE path index > 5 `
- TRUEVALUE \[value]
	- This allows you to pass in booleans directly. This is usually useless, but has some interesting niche cases. You can also *technically* pass floats using this as well, but I am unsure of any scenarios where this would be remotely useful for this release
	- This might look like

These can also be compared using the supported set of operators (defined below this paragraph). Here are some examples:

```
	"Text 1" : VALUE path indexOne > 5 OR VALUE path indexTwo < 8
		GOTO x()
	"Text 2" : VALUE path deaths > 5 AND FLAG globalPath "ExampleFlag"
		GOTO x()
	"Text 3" : FLAG globalPath "KilledJohn" > 5 XOR FLAG globalPath "TalkedToJohn" 
		GOTO x()
	"Text 4" : VALUE path deaths == 5 AND VALUE path kills != 0
		GOTO x()
	"Text 5" : TRUEVALUE false RAND TRUEVALUE true # Returns true 50% of the time
		GOTO x()
```

Implemented list of operators:
OR, AND, NAND, XOR, NOR, >, <, <=, >=, =, \==, !=, RAND 
(RAND returns one of the two values randomly)
### The Actions
After a choice is selected, what can we do? Well, here's a list:
- END
	- This ends the dialogue tree, and emits the signal "done"
- GOTO \[FunctionName] ()
	- Runs the function \[FunctionName]. This should look like : `GOTO FuncOne()`
- ADDFLAG \[node_path] \[flag]
	- Adds \[flag] to the "Flags" variable \[node_path]
- SUBFLAG \[node_path] \[flag]
	- Removes \[flag] to the "Flags" variable \[node_path]
- SET \[node_path] \[variable_name] \[value]
	- Sets \[variable_name] at \[node_path] to \[value]
- ADD \[node_path] \[variable_name] \[value]
	- Adds \[value] to \[variable_name] at \[node_path]
- SUB \[node_path] \[variable_name] \[value]
	- Subtracts \[value] from \[variable_name] at \[node_path]
- MUL \[node_path] \[variable_name] \[value]
	- Multiplies \[variable_name] at \[node_path] by \[value] 
- DIV \[node_path] \[variable_name] \[value]
	- Divides \[variable_name] at \[node_path] by \[value] 
- SIGNAL
	- Emits the signal "dialog_signal"
	- Can be used in conjunction with temporary flags to great effect

As long as each action has the valid arguments, you write as many as you want on a line seperated by spaces.
eg:
`ADDFLAG main_path "ExampleFlagOne" GOTO FunctionThree()`
`SUBFLAG main_path "TestFlag" SET Inventory Money 50 SIGNAL GOTO FunctionThree()`
`MUL main_path testValue 10 SIGNAL END`

---
## Variables and paths

At the top of every script, you can define paths, variables and standins (a special variable type)
In the current version, 1.0, variables are just references to the names of variables stored in the GDscript you're accessing via a path. It may sound a bit redundant, but it works! Hopefully, these will become depreciated in the next major version. Speaking of, I also plan on adding constants in the next version, although they are very low priority, because they are never necessary, just kind of useful.

#### Variable syntax
`var [this variable's name] [name in GDscript]
OR
`val [this variable's name] [name in GDscript]

When referencing the variable "Money" at the path `/root/Inventory` you would need one path and one variable.
`path inventory "/root/Inventory"`
`var money Money`
Now, if you wanted to get the value, you would use `VALUE inventory money`
eg:
`VALUE inventory money > 50` (In the Requirements stage of options)
`ADD inventory money 20` (In the Actions stage of options)

#### Path syntax
`path [this variable's name] [path in GDscript]

This is used whenever a variable in GDscript needs to be modified or checked, whenever a flag needs to be checked, added, or removed, and whenever a standin is defined.

The easiest way to utilize this in a scene where you don't know the structure of the nodes is to use a singleton. or global script/node, as they are easy to get a path to. If you didn't know, in GD script, you can call `get_node("/root")` to get the root node. that being said, to get any singleton to be a path in G-Discuss, you should do something like this:
`path testPath "/root/[singleton name]"`
If I had a singleton called "InventoryData", and wanted a path to it, it would look like this:
`path inventory "/root/InventoryData"`

#### Standin syntax
`standin [GDiscuss_variable_name] [path of variable] [name of variable in GDscript]`

Because they require a path to be defined, define these after you've defined paths in code.

standins are used to display variables in dialogue, such as
`standin name main_path currentName` 
where currentName is "John"
`"I'm {name}"` will be displayed as `"I'm John"`
Or
`standin amount inventory myMoney` 
Where myMoney is 368
`You have {amount} Gold` will be displayed as `You have 368 Gold`.

---
## Formatting text

BBCode is fully supported, just look through Godot's native documentation for information on that. It is supported in both the dialogue display and the play options. There is also a custom thing for adding line breaks in dialogue, which is `[br]`.
Here is an example of BBCode:
```
[font_size=50][Center]Hello![\Center][\fontsize]
[rainbow]Text can be rainbow,[\rainbow][br][bwave]Wavy,[\bwave][br]And more!
```
The addon has been released with some custom BBCode as of 1.0, consisting of:
- \[bwave] - A better wave effect
- \[bshake] - A better shake effect
As more are added in future updates, a separate section may be added for them.

There is also a way of doing very basic procedural formatting of text, useful if a characters name might not be fixed, such as the player's name.

```
path main_path "/root/GlobalVariables"
standin name main_path currentName
```
Here, we define two variables, "main_path", and "name".
A stand in variable can be defined with the following syntax:
`standin [GDiscuss_variable_name] [path of variable] [name of variable in GDscript]`
This means 
`standin name main_path currentName`
Will create a new variable called "name" that we can use as a stand in later, and it references the variable "currentName" that is a property of the node at "main_path", which in this case is a singleton.
To use a stand in, in any dialogue, we can write `{name}` and it will be replaced with the variable it's referencing in GDscript. If "currentName" has a value of "John", then `{name}` will be displayed as "John".
